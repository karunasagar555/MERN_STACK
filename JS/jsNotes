NOTE : Javascript is a synchronous and single-threaded language (meaning it can only do one thing at a time and in a specific order)





///// Function Statements & Function Expressions

Q) what is a Function Statement ?

S:  function a() {
       console.log("a called");
}

NOTES : Functions are HEART of JS, they are the FIRST CLASS CITIZENS.

Q) what is a Function Expression ?

S: we can assign a function to a variable, function acts like a value here, we are putting function into b.

var b = function () {
    console.log("b called");
}

NOTE : both Function Statements and Function Expressions are ways to create functions, the difference between these is in HOISTING.



















////// Event Bubbling and Event Capturing

1) what is Event Bubbling ?

s: Bubbling 


2) what is Event Capturig ?

s: it is an event which trickles down the DOM hierarchy, it has a performance issue and is very expensive

Note : Eventbubling is used by default if we do not pass any third argument insdie the eventlistener function

Note : Event Capturing is also known as Event Trickling

Note : According to W3C model the whole chain is anyways followed, the trickling down happens then the bubbling up happens whether you do anything 

Note : According to W3C, first the event propogation happens TOP-DOWN the hierarchy ie Capturing happens first than bubbling out happens and the callback methods are called according to the parameters what we pass (true and false) 

Q) what are callback Functions in JS ?
S: the function which is passed into another function is known as a callback function.

Q) what is the significance of this callBack function ?
S: this function is very powerful in JS, it gives us access to the whole Asynchronous world in a synchronous single-threaded language, because of callBack functions we can do ASYNCHRONOUS things inside JS.

Q) what is MAIN THREAD ??
s : // callStack aka MAIN THREAD, callstack is also called as MAIN THREAD.


Q) what is blocking the MAIN THREAD ?
s: if any operation blocks this callstack that is called blocking the MAIN THREAD.


Q) what is setTimeout ?
S: It is a web API/Browser API

Q) how can we stop blocking the main thread ?
S: we have to carry out Asynchronous operations in such cases, callBack functions help us to carry ASYNC Tasks, hence we can save the thread from blocking.

NOTE : using WEB APIs(eg: setTimeout()) and callBack functions we achieve carrying out ASYNC Tasks.




//EVENT LOOP IN JS


// Akshay Saini Comments 

1. When does the event loop actually start? - Event loop, as the name suggests, is a single-thread, loop that is `almost infinite`. It's always running and doing its job. ‚ù§Ô∏è

2.  Are only asynchronous web API callbacks are registered in the web API environment? - YES, the synchronous callback functions like what we pass inside map, filter, and reduce aren't registered in the Web API environment. It's just those async callback functions that go through all this.

3. Does the web API environment stores only the callback function and pushes the same callback to queue/microtask queue? - Yes, the callback functions are stored, and a reference is scheduled in the queues. Moreover, in the case of event listeners(for example click handlers), the original callbacks stay in the web API environment forever, that's why it's advised to explicitly remove the listeners when not in use so that the garbage collector does its job.

4. How does it matter if we delay for setTimeout would be 0ms. Then callback will move to queue without any wait? 
No, there are trust issues with setTimeout() üòÖ. The callback function needs to wait until the Call Stack is empty. So the 0 ms callback might have to wait for 100ms also if the stack is busy. 

END//


NOTE : JS is synchronous single threaded language. But due to some functions like setTimeout, callback functions and AJAX it can behave asynchronously in order to speed up the process.'Time, Tide and JS waits for none!'.




1. Browser has superpowers that are lent to JS engine to execute some tasks, these superpowers include web API's such as console, location, DOM API, setTimeout, fetch, local storage.
2. Callback functions and event handlers are first stored in Web API environment and then transferred to callback queue.
3. Promises and mutation observer are stored in API environment and then transferred to microtask queue.
4. Event loop continuously observes call stack and when it is empty it transfers task to call stack.
5. Micro task is given priority over callback tasks.
6. Too many micro tasks generated can cause Starvation (not giving time to callback tasks to execute).